IRQ Driven ESP AT command ZX Next driver
----------------------------------------

V0p5 Alpha

(c) Tim Gilberts, Infinite Imaginations, 2018

This is the initial release of an Interrupt driven UART/ESP driver using the
loadable device drivers of NextZXOS.  It uses a 24K buffer in the given
memory BANK(s) or in main memory at $A000/40960 if none is specified.

Only a single command channel and a single outbound channel are supported
you can open extra channels but, they will be reported as invalid handles.

IPD packets use border colour changes for diagnostics this may or may not
be kept and or able to be be disabled...  CMD channel ones do not.

Initially this supports NextZXOS BASIC streams but, we will also supply a 
semi Spectranet / sockets compatible API at some point.

The IRQ driver is used INSTEAD of the UART one previously developed to
improve buffer handling etc so that +IPD packets can be written directly
to the allocated memory buffers.

It is loaded as with other IM1 drivers using:

.install /NextZXOS/espat.drv

It can also be removed with

.uninstall /NextZXOS/espat.drv

Until those commands support loading additional pages you MUST manually load
the ESPAT.SYS into a suitable memory page.  This 16K BANK uses the top 8K as a
command receive buffer.  You can either use the default main memory of the
Next or supply a 16K bank using the ASM API or from BASIC using DRIVER.

Note that it starts in a limited fashion only gathering the status of the
UART data ready and buffer full flags.  This is so that data does not
overwrite any memory until you have formally assigned a bank or decided
to use the top 24K of main memory explicitly with a CLEAR 40959 command.

It supports an API that can be used from BASIC using a mix of DRIVER and
Streams support.  The driver can also be used from Assembler with
the NextZXOS driver API commands (see summary of M_DRVAPI at end of this
or in main NetxOS API documentation) where the Streams functions are just API
calls greater than 127...

It's ID is 'N' which is 78 decimal.  So all BASIC DRIVER commands are

DRIVER 78,n,{param1{,param2{ TO var1{,var2{,var3}}}}}

where n is the API call id / function number required.

Note if you use the pluspack AUTOEXEC then %n will be 78 if loaded so you can
say DRIVER %n,.... for clarity

On entry in assembler, use B=call id with HL,DE other parameters.
(NOTE: HL will contain the value that was either provided in HL (when called
from dot commands) or IX (when called from a standard program).

;Use IDE_DRIVER ($01CF) to open ESP or via NextZXOS M_DRVAPI ($92)
;Error return if it is not loaded or present.

		LD	C,'N'	;We want to open the ESPAT driver for use
		LD	B,$f9	;Open the channel
		LD	DE,0	;No params
		LD	HL,0	
		RST	8
		DEFB	$92	;m_DRVAPI
		JR	C,Init_Error
		LD	(ESPAT_cmd_handle),A

When called from the DRIVER command, DE is the first input and HL is the 
second.

When returning values, the DRIVER command will place the contents of BC into
the first return variable, then DE and then HL.  Just use them directly in
assembler...

Codes from 64-127 are used by built in functions to control IRQ etc for stream 0
which is the ESP Command channel.

Codes from 1-126 are used by ESPAT.SYS to provide extended functions for the
main data streams 

Remember that >127 are the Streams API calls $F9 = 249... which is Open.

The UART will begin to lose data if it misses more than one interrupt
at 115K baud on the UART/ESP interface. So be very careful with DI/EI and
any SD card access...  Some BASIC commands may have an effect as well so best
to run at 14MHz probably!  Internally the code polls when waiting so that
data is not lost during stream and driver operation as that runs DI.

Timeouts in IPD data streams can be seen as Tilde ~ characters of the quantity
we were expecting - they are just lost on the Command stream as we have no idea
how many we lost.


;------
; B=64: Get CMD stream0 values
;------
Get CMD buffer values including flags C=Flag status

;Bit 0 = internal
;Bit 1 = 8K SW command buffer overwrite error state (temp)
;Bit 2 = UART 512Byte HW FULL error state (temp)
;Bit 3 = internal
;Bit 4 = internal (buffer max marker)
;Bit 5 = IPD packet seen flag
;Bit 6 = IPD packet mode receive disable when 1
;Bit 7 = We are disabled when 1

Note that BIT 7 is buffer full flag on other streams - stream 0 works in a 
different way.

DE and HL are input and output positions on the ESP CMD read buffer respectively

This also has the effect of starting the Data and IPD receive by resetting
bits 6 and 7

;------
; B=65: Set CMD stream0 values
;------
Set values of input and output buffer directly, this can either be a relative
offset value in the 8K buffer < 8192 or the actual address in C000-FFFF

This will also clear some flags and start TSR execution.

Setting DE=HL means empty buffer at that point.

*** This is for advanced use really

;-----	
;B=66: WAS Set RX timeout for command channel.
;-----

As of Alpha 4 this is no longer necessary will be repurposed.

;------
; B=67: Set memory bank for CMD and SYS
;------
Set available memory pages to use for SYS and CMD buffer - ignores upper values
of MSB

Converts a 16K BASIC BANK to two 8K pages - assumes they are contiguous and
available to the driver which then splits them up to page in at $A000 and $E000!

If you do not give it a bank then when it starts running it will begin to write
to main memory so make sure you have done a clear 40959 before starting it up by
calling the get or set values/flags calls.

Note that until you make this call the system will not work as this also
does initial setup.  Using 0 as param will allow it to explicity set 5 and 0
as MMU5 and MMU7 for use. Otherwise it takes a contiguous 16K bank number.

***TODO

There is unlikely to be many more IRQ system DRIVER commands added...


;----
;B=1: Specific UART BAUD rate to be set from lookup table.
;----

Set Baud rate / prescaler DE {HL}, returns used prescaler value in BC, 
If DE is <15 then set prescaler to that - if 255 then use second value.
Actually uses it if it is not a valid one...

It supports a limited number of built in prescale values as of course
You can supply your own via DRIVER/HL command and it is mainly intended
to support the ESP8266 Network interface which only needs a few speeds.

	DEFW 243,248,256,260,269,278,286,234 ; Was 0 - 115200 adjust for 0-7
	DEFW 486,496,512,521,538,556,573,469 ; 1 - 56k
	DEFW 729,744,767,781,807,833,859,703 ; 2 - 38k
	DEFW 896,914,943,960,992,1024,1056,864 ; 3 - 31250 (MIDI)
	DEFW 1458,1488,1535,1563,1615,1667,1719,1406 ; 4 - 19200
	DEFW 2917,2976,3069,3125,3229,3333,3438,2813 ; 5 - 9600
	DEFW 5833,5952,6138,6250,6458,6667,6875,5625 ; 6 - 4800
	DEFW 11667,11905,12277,12500,12917,13333,13750,7 - 11250 ; 2400
	DEFW 122,124,128,130,135,139,143,117 ; 230400 -8	
	DEFW 61,62,64,65,67,69,72,59 ;460800 -9
	DEFW 49,50,51,52,54,56,57,47 ;576000 -10
	DEFW 30,31,32,33,34,35,36,29 ;921600 -11
	DEFW 24,25,26,26,27,28,29,23 ;1152000 -12
	DEFW 19,19,20,20,21,21,22,18 ;1500000 -13
	DEFW 14,14,15,15,16,16,17,14 ;2000000 -14
	
If DE=255 then use second value in HL directly as the prescaler.
Note that your own prescaler MUST correct for the video timing
as in the above table which represents VGA0-6 and HDMI7

;-----
; B=2: Get IPD values
;-----
DE is the actual channel handle you were given

Get values including buffer full flag and ESP internal stream number /flags in C

Low nibble is num 0-7
BIT 4 = Output buffer full
BIT 5 = Embedded IPD seen - stream restarted
BIT 6 = Timeout in last period
BIT 7 = Buffer filled in last period

DE and HL are input and output positions on the ESP IPD read buffer.

These are actual memory address values in your assigned BANK
assuming it is paged at 49152.

Top two flags; the Timeout/ Buffer full flags are cleared by this call
so that each time it is used you can see if there may have been data loss.

;-----
; B=3: Set IPD values
;-----
DE is the actual channel handle you were given

Set values of input and output buffer directly, giving 0's will reset the
command buffer to empty.  You can use a relative offset (best) or the actual
address.

All flags are cleared by this call as well.

;-----	
; B=4: Set IPD timeouts
;-----
Global for ESP Links and Command - does not need a channel handle.

Set RX/TX timeout - allows you to wait for variable periods for send
and receive before the system decides there is no more data or the
outbound UART is not emptying.

;-----
; B=5: Add 16K bank to IPD receive pool
;-----
Global - does not need a channel handle.
***TODO Temp until pooling implemented will add to DE channel BANKno1 directly

add memory pages to available buffer pool 
ignores upper values of MSB, needs a full 16K BASIC BANK as that is the size
of the IPD receive buffers.

***Alpha - only one BANK can be added to the pool at the moment as only one
stream is available and double banking is not implemented in the API 

***TODO
=======

;-----
; B=6: Get ESP Link ID from handle
;-----
DE is the handle to the channel.

Returns currently associated LinkID or -1 if there is none.

B=7 .... etc

Use the DRIVER command to pass in / get packets of data rather than single
bytes - especially useful for UDP datagrams to a stream.
so like sendto() and recvfrom()
This will likely be provided as a 256/512 byte block in the BASIC workspace.

It will also support getting a 16K BANK back as a whole buffer from a channel.
The channel system allows swapping between two sets of 16K for double buffering.
This will make block work faster for large receives




Steams support
==============

The driver supports the streams interface as follows:

Remember you have a BASIC stream <> channel(handle) {<> ESP LinkID}


;-------
; B=$f9:  open channel
;-------

OPEN #n,"D>N"         ; simple open: HL=DE=0 Means OPEN command channel
OPEN #n,"D>N>string"  ; open with string: HL=address, DE=length
                       ; NOTE: be sure to check for zero-length strings
OPEN #n,"D>N,p1,p2"   ; open with numbers: DE=p1, HL=p2 (zeros if not prov.)
The last form will open the command channel with no numbers/0's, or p2 is a
pointer to a string of length p1 which MUST be somewhere below the 40K mark.

For the network driver you DO NOT NEED to open a stream to the command channel
first that can be done when you want.

It can also be closed independently as well.

OPEN #n, "D>N"
  opens the ESP AT command channel so that you can see the rolling
  data and query more complex data.  Prints to this channel are
  sent 'as is' so you can send other commands.
  Note that the system checks this channel and deals with some commands
  related to status
  
  This channel is'cooked' and adds an LF after CR and changes it to another
  CR on receive so that BASIC just sees an extra blank Line.
  
  ***TODO unlike other channels it will not block - you may receive a timout
  return, this allows INPUT to be used to get responses but, not hang
  and still find the end of a sequence etc. This will be char 0 or null string
  NON blocking may not be possible as it is built into BASIC and is not
  selective

OPEN #n, "D>N>CTCP/UDP/SSL,address or ip,port" 
  This is effectively getaddrinfo() (was gethostbyname) + socket() + bind()
  and then connect()!
  Issues an ESP  AT+CIPSTART=x,"TCP","address",port and deals with any error
  messages to return.
  
  ***TODO the string is currently ignored but, the channel will always
  succeed in opening if you have provided a memory page so you can then
  PRINT #x,"AT+CIPSEND="+CHR$(34)+"TCP" ... or send the string in ASM...
  then you can INPUT #x to wait for CONNECT or other errors. 

***TODO - Highly likely to be used method
; OPEN #n, "D>N>LXXXX" - 
;   Creates a server listening on port XXXX

;  (Might be better as DRIVER 78,y,XXXX as the stream number will be unknown
;  less use although it could be used for CLOSE with reads triggering the
;  search in the command channel for the value,CONNECT to go in the OPEN?)
   
; OPEN #n, "D>N>A"
;   which will do the accept() for BASIC ... when a server is started then
;   the incoming next ESP Link will be used for data receipt so the ID is
;   unknown until the first connect is received - so we need
;   to track the CIPSTATUS immediately after a connect - unless we have that
;   the above call will fail, when we do then it will succeed so it can be
;   used to poll for a new connection and assign a BASIC stream to that connect
;   timing out if not received within a short period. ERROR ON will be needed
;   to deal with that as OPEN does not return a value.
;
; OPEN #n, "D>N>X"
;   If D is added then IPD debug data is returned. Along with x,CONNECT etc to
;   responses received back rather than suppressing them. i.e. DEBUG
;   any IPD packets are written to the buffer if received before you have
;   provided any other buffers - this is unlikely to happen unless you
;   send connects or listens yourself in which case the small buffer will be
;   hard to handle.
;
; OPEN #n, "D>N>D'address or ip',port"  - activate a remote debug/syslog service
;   anything printed to the channel will be sent to that address and port
;   using UDP.
;
; MAYBE: OPEN #n,"D>N>R' for a RAW stream that allows you after a 
;   RETURN #n TO h and DRIVER 78,6,h TO l will make l the current associated
;   ESP LinkID (0-4) - where x is the function call to get any Link currently
;   associated with one of our driver channels.
;
; The ESP8266 has a limited number of network connections it can handle called
; LinkID's (0-4) which are set by the CIPSTART command for example.
;
; ***TODO Only 1 SSL channel is allowed so that is specifically checked.
;
; Note that closing ESP id 5 will close all channels except if in server mode so
; we do not allow that from the streams API at the moment.
;
; You must have added at least a single 16K memory bank for buffers via the API
; to allow an open to succeed. If you do not then all IPD data will just be in
; the command stream and the buffer will exhaust quickly. 

Channel handle is returned in A - this cannot be accessed in BASIC so see
B=$fd / RETURN #n TO var 

If it returns with any error (carry set), "Invalid filename" will be reported
and no stream will be opened.
 
;-------
; B=$fa: close channel
;-------
This call is entered with D=handle, and should close the channel
If it cannot be closed for some reason, it exits with an error (this will be
reported as "In use").

CLOSE #n

;-------
; B=$fb: output character
;-------
This call is entered with D=handle and E=character.
Returns with carry set and A<$fe, so the error
"Invalid I/O device" will be reported on a timeout for send.

; **TODO we should add a small output buffer to prevent any blocking then
; use the End of file error return if it is filled before transmission.
; This will have to be added to the IRQ routine for transmission but space
; is limited at the moment unless we switch to a TSR and memory block solution

PRINT #n
plus others like LIST etc.

;-------
; B=$fc: input character
;-------
This call is entered with D=handle.
Returns the character in A (with carry reset).
If no character is currently available, returns with A=$ff and carry set.
This will cause INPUT # or NEXT # to continue calling until a character
is available.
This will clear any SW buffer full flags so make sure you have checked for
data loss by reading the flags first.

;-------
; B=$fd: get current stream pointer
;-------
This call is entered with D=handle.

;***TODO this is likely the way we will return the assigned ESP stream to
; BASIC for use afer an accept()
We will use this to allow BASIC to get the internal handle to pass
to the driver command for a specific stream.  The handle is an index to
our internal streams 0-5 from where the ESP channel # can be obtained.

You should return the pointer in DEHL (with carry reset).  I.e. HL will be
the internal ESP channel number.

This is used with RETURN #n TO var

;-------
; B=$fe: set current stream pointer
;-------
This call is entered with D=handle and IXHL=pointer.
Exit with A=$fe and carry set if the pointer is invalid (will result in
an "end of file" error). This means you are trying to skip more
bytes than there are in the buffer or 0 bytes.
NOTE: Normally you should not use IX as an input parameter, as it cannot
      be set differently to HL if calling via the esxDOS-compatible API.
      This call is a special case that is only made by NextZXOS.
This can be used to ADD x bytes to the stream to bulk skip over incoming
data - it cannot be used to rewind the stream, error if x is > extent
This will clear any SW buffer full flags so make sure you have checked for
data loss by reading the flags first.

This is used with "GOTO #n,m" 

;-------
; B=$ff: get stream size/extent
;-------
This call is entered with D=handle
Returns the size/extent in DEHL (with carry reset).
This is the number of bytes in the input buffer at the moment.

This is used with "DIM #n TO var"




NextZXOS API's
==============

As a reminder here is the NextZXOS API documentation for M_DRVAPI - please check
that for most up to date version as it could have changed since this
was written.  It is of course best to use the full NextZXOS API...

	
; *************************************************************************
; * M_DRVAPI                                                                *
; *************************************************************************
; Entry:
;       C=driver id (0=driver API)
;       B=call id (or as described by driver documentation)
;       HL,DE=other parameters
; Exit (success):
;       Fc=0
;       other values depend on API call
; Exit (failure):
;       Fc=1
;       A=0, driver not found
;       else A=driver-specific error code (esxDOS error code for driver API)

; If C=0, the driver API is selected and calls are as follows:
;
; B=0, query the RTC
; (returns the same results as M_GETDATE)
;
; B=1, install a driver
;       D=number of relocations (0-255)
;       E=driver id, with bit 7=1 if should be called on an IM1 interrupt
;       HL=address of 512-byte driver code followed by D x 2-byte reloc offsets
; Possible error values are:
;       esx_eexist (18)         driver with same id already installed
;       esx_einuse (23)         no free driver slots available
;       esx_eloadingko (26)     bad relocation table
;
; B=2, uninstall a driver
;       E=driver id (bit 7 ignored)
;
; B=3, get paging value for driver banks
;       C=port (always $e3 on ZXNext)
;       A=paging value for DivMMC bank containing drivers (usually $82)
;
;IX when called from outside a dot command, HL is for internal use (and dot commands)



Notes:
======


a) Why not 8K buffers?

A 16K BANK buffer is used as that can cope with 3 full size IPD packets per
used stream. According to this post:

https://bbs.espressif.com/viewtopic.php?t=1575

Max IPD packet size can be 4x1460 = 5840 bytes!!!!


b) SSL connect does not yet work...

On the SSL question as at Feb 2017

https://bbs.espressif.com/viewtopic.php?f=16&t=3381

Our AT Framework can be used in HTTP, not HTTPs. If using HTTP, you should add some code in your project, and you can refer to the demo code as below:
https://github.com/espressif/esp8266-nonos-sample-code/tree/master/04Protocal/IoT_Demo_https


3) Teletext?

http://teastop.plus.com:8080/

4) BASIC

Installer for the moment

.install /nextzxos/espat.drv
PRINT "Installed ESPAT.DRV"
BANK NEW %m: PRINT "ESPAT.SYS Load page ";%m
LOAD "/nextzxos/espat.sys" BANK %m,0,exactlength (will fix file at 8192 for simples)
DRIVER 78,67,%m:REM ensures DRV knows where SYS is and patches/initialises
BANK NEW %b: PRINT "Allocating 1 buffer ";%b
DRIVER 78,5,%b
DRIVER 78,1,0 TO %p : PRINT "115K Baud - precaler ";%p
DRIVER 78,64 : PRINT "Driver started"

This is in the autoxec-pluspack.bas - if you hold ENTER while booting it will
not autoload so you can pick individual drivers or just then use space to boot
with none

Change Log
==========

;Alpha 5 30 July 2018
------------------------

Bug from refactoring code to .SYS on buffer size corrected - this caused "end
of file" errors on INDEMO104.BAS so it bombed out occasionally.

The timeouts seen by Robin on send using ESPDEMO16.BAS can be reduced by
increasing the timeout value with a DRIVER 78,4,1024 but, it makes it even
slower sending a character. In ASM you just need to retry on error - BASIC will
bomb and the ON ERROR will exit the program - you could change this to PAUSE
and then retry probably. This is a bug in the way the ESP is driven I think.
The number of "busy..." messages skipped has doubled but, it still seems to
happen.  However the code is rock stable for receiving data and you can send
some small messages on the data channel so it works enough for experimenting.

;Alpha 4 29 July 2018
------------------------

You can now open and close streams (including command channel) in any order
so once OPEN string is working you will not need command channel in normal use.

B=66 removed from Command API

Line in above example loader missing DRIVER 78,67,%m (even if in RAM need %m=0)
as this also triggers the initialise code!!!

Bugs in AUTOEXEC.BAS fixed like last item...

Refactored all possible DRV code into SYS as as had run out of room for diags.

Shortened and optimised send path / CMD buffer stream for speed

CMD channel now cooked - on input an LF will become a CR so appears as extra
line.  On output an LF is added.

Send is working for IPD channel but hellish slow - need to add buffering and
provide some form of flag control to turn that on and off, set buffer size etc
Meanwhile think of it as working with a Retro experience 1200/300 baud modem :)

I have included a copy of the BASIC test harness I use that loads the driver
so you do not have to have the AUTOEXEC.BAS setup. So you have:
INDEMOxxx.BAS which is the test harness I use - you can type AT commands and
see incoming packets - it auto connects to 192.168.0.2:10000 but that is a line
you can change.  I run nc -l 10000 on the PC to provide a test connection.
"autoexec-pluspack.bas" which is the loader with temp code pending .install 
being able to allocate pages - at which point DIVMMC memory will be used for SYS
ESPDEMOxxx.BAS uses the autoexec loaded driver to be similar to the harness
but the sent data goes to the IPD channel not the command channel.

Main memory API test call now prints correct Version number

;Alpha 3 27 July 2018
------------------------

First public showing - send on opened IPD channel broken, receive only.

;Alpha 2 and Alpha 1
------------------------

Internal non working code scavenged from .UART, UART.DRV, TERMINAL.BIN etc

