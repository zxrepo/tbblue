///////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////
#include "DotCommandShared.h"


/*
You can generate actual basic errors by returning a non-zero value.

The canned esxdos messages are here if one fits:

https://github.com/z88dk/z88dk/blob/master/include/_DEVELOPMENT/sdcc/arch/zxn/esxdos.h#L512

Or you can return a string with last char having bit 7 set.  Sometimes I try to match sinclair basic errors in form:

http://www.worldofspectrum.org/ZXBasicManual/zxmanappb.html

And I think nextzxos probably has a few more basic errors


----
You can change that line to "defb __ESX_F_RMDIR" in arch/zxn/esxdos/z80/asm_esx_f_rmdir.asm
 and then rebuild the zxn library from z88dk/libsrc/_DEVELOPMENT  "make TARGET=zxn"


----
basename, dirname and pathnice are in <libgen.h>

https://github.com/z88dk/z88dk/tree/master/libsrc/_DEVELOPMENT/libgen/z80

they will not understand drive specifier but dirname/basename might help with -p.
They should work as in the posix standard:

http://pubs.opengroup.org/onlinepubs/009696799/functions/dirname.html

http://pubs.opengroup.org/onlinepubs/009604499/functions/basename.html

----
the user could do soemthing silly like 

.rmdir "  c:   /foo/thing"

pathnice removes leading whitespace by moving the ptr forward and removes trailing ws by writing a 0 to terminate the string early.
So the first pathnice will get you to c:.  You walk past that to the space.
Another pathnice (or a strstrip) will move to the / and then this is what dirname operates on.
dirname will write a 0 into the path to chop off the last part of the path.

so after first dirname you will have 

"c:   /foo"

and then 

"c:   /"

forever.  So termination condition is "." or "/" string.  Maybe.
*/

///////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////
unsigned char pathname[512];  // read buffer

#define ebuf pathname

void PrintFormatted(char *fmt, ...)
{
   va_list v;
   va_start(v, fmt);

#ifdef __SCCZ80
   vsnprintf(ebuf, sizeof(ebuf), va_ptr(v,char *), v);
#else
   vsnprintf(ebuf, sizeof(ebuf), fmt, v);
#endif

	printf(ebuf);
}

///////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////
void PrintErrorMessage(unsigned int error)
{
	const char* msg = NULL;

	switch (error)
	{
		case ESX_OK:			msg = "0 OK"; 						break;
		case ESX_EOK:			msg = "O.K"; 						break;
		case ESX_ENONSENSE:		msg = "Nonsense in ESXDOS"; 		break;
		case ESX_ESTEND:		msg = "Statement END error"; 		break;
		case ESX_EWRTYPE:		msg = "Wrong file TYPE"; 			break;
		case ESX_ENOENT:		msg = "No such FILE or DIR"; 		break;
		case ESX_EIO:			msg = "I/O ERROR"; 					break;
		case ESX_EINVAL:		msg = "Invalid FILENAME"; 			break;
		case ESX_EACCES:		msg = "Access DENIED"; 				break;
		case ESX_ENOSPC:		msg = "Drive FULL"; 				break;
		case ESX_ENXIO:			msg = "Invalid I/O REQUEST"; 		break;
		case ESX_ENODRV:		msg = "No such DRIVE"; 				break;
		case ESX_ENFILE:		msg = "Too many OPEN FILES"; 		break;
		case ESX_EBADF:			msg = "Bad file DESCRIPTOR"; 		break;
		case ESX_ENODEV:		msg = "No such DEVICE"; 			break;
		case ESX_EOVERFLOW:		msg = "File pointer OVERFLOW"; 		break;
		case ESX_EISDIR:		msg = "Is a DIRECTORY"; 			break;
		case ESX_ENOTDIR:		msg = "Not a DIRECTORY"; 			break;
		case ESX_EEXIST:		msg = "File already EXISTS"; 		break;
		case ESX_EPATH:			msg = "Invalid PATH"; 				break;
		case ESX_ENOSYS:		msg = "No SYS"; 					break;
		case ESX_ENAMETOOLONG:	msg = "Path too LONG"; 				break;
		case ESX_ENOCMD:		msg = "No such COMMAND"; 			break;
		case ESX_EINUSE:		msg = "File in USE"; 				break;
		case ESX_ERDONLY:		msg = "File is READ ONLY"; 			break;
		case ESX_EVERIFY:		msg = "Verify FAILED"; 				break;
		case ESX_ELOADINGKO:	msg = "Loading .KO FAILED"; 		break;
		case ESX_EDIRINUSE:		msg = "Directory NOT EMPTY"; 		break;
		case ESX_EMAPRAMACTIVE:	msg = "MAPRAM is ACTIVE"; 			break;
		case ESX_EDRIVEBUSY:	msg = "Drive is BUSY"; 				break;
		case ESX_EFSUNKNOWN:	msg = "Unknown FILESYSTEM"; 		break;
		case ESX_EDEVICEBUSY:	msg = "Device is BUSY"; 			break;

		default:				msg = "Unknown";					break;
	}

	if (msg != NULL)
	{
		PrintFormatted("Error %u, %s\n", error, msg);
	}

//	ebuf[strlen(ebuf)-1] += 0x80;
//	exit ((int)ebuf);
}

///////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////
char* MakeNicePath(char* path)
{
	char* newPath = pathnice(path);
	char* skipDrive = strchr(newPath, ':');
	if (skipDrive != NULL)
	{
		newPath = skipDrive + 1;
	}

	newPath = pathnice(newPath);	// strip leading whitespace

	return newPath;
}
